# 第一章 关于this
## 💥调试
用 `debugger`
## 为什么要用`this`
- `this`提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用
- 随着使用的模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用`this`则不会这样
## `this`在任何情况下都不指向函数的词法作用域？为啥？

## `this`到底是什么？
- ❓❓❓❓`this`是在运行时进行绑定的，并不是在编写时绑定（两者有啥区别吗？？？？？？？
- `this`的上下文取决于函数调用时的各种条件
- `this`的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式
- 当一个函数被调用时，会创建一个执行上下文（execution context），这个execution context会包含函数在哪里被调用（调用栈 call stack）、函数的调用方式、传入的参数等信息。`this`就是这个execution context的一个属性，会在函数执行的过程中用到

## 小结
- `this`既不指向函数自身也不指向函数的词法作用域
- `this`实际上是在函数被**调用**时发生的绑定，它指向什么完全取决于函数在哪里被**调用**

# 第二章 this全面解析
## 调用位置
- 调用位置就是函数在代码中被调用的位置（而不是声明的位置）
- 我们要找的调用位置就在当前执行的函数的前一个调用中

## 1. 默认绑定
- 立即执行函数中调用函数，this指向问题？
- 对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。

## 2. 隐式绑定
- 调用位置是否有上下文对象，或者说是否被某个对象拥有或包含
- 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象
- ⭐对象属性引用链中只有上一层或者说最后一层在调用位置起作用（就近原则？）
- 在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上
## 隐式丢失
- 一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。
- 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值
- 调用回调函数的函数可能会修改this

## 3. 显式绑定
- 显式绑定：使用call或者apply方法，在调用函数时将其绑定到this，它们第一个参数可以指定this绑定的对象
- 从this绑定的角度来说，call()和apply()是一样的，它们的区别体现在其他的参数上
- ❓传入原始值作为this绑定对象？？？“装箱”？

## 硬绑定（显示绑定的变种
- Function.prototype.bind()会创建一个新的包装函数，这个函数会忽略它当前的this绑定（无论绑定的对象是什么），并把我们提供的对象绑定到this上

## API调用的“上下文”
- 第三方库的许多函数，以及javascript语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和bind()一样，确保你的回调函数使用指定的this
- 例如forEach(),这些函数实际上就是通过call()或者apply()实现了显式绑定
## 4. new绑定
- 在javascript中，构造函数只是一些使用new操作符时被调用的函数
- 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
  - 创建（或者说构造）一个全新的对象
  - 这个新对象会被执行`[[Prototype]]`连接
  - ⭐这个新对象会绑定到函数调用的this
  - 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象
- 为什么要在new中使用硬绑定函数呢？直接使用普通函数不是更简单吗？
  > 之所以要在new中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数。bind()的功能之一就是可以把除了第一个参数（第一个参数用于绑定this)之外的其他参数都传给下层的函数（这种技术称为“部分应用”，是“柯里化”的一种）

## 优先级
- 默认绑定优先级最低
- 显式绑定优先级 > 隐式绑定优先级
- new 绑定 > 隐式绑定优先级 
- new 绑定 > 显式绑定优先级

## 判断this
- 函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。
  `var bar = new foo()`
- 函数是否通过call,apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。
  `var bar = foo.call(obj2)`
- 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。
  `var bar = obj1.foo()`
- 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined,否则绑定到全局对象。
  `var bar = foo()`

## 绑定例外
### 被忽略的this
- 如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则
- 什么情况下会传入null？
  > 1. 使用apply()来展开一个数组，并当做参数传入一个函数
  > 2. 使用bind()进行柯里化
- 在ES6中可以用`...`操作符代替apply()来展开数组，`foo(...[1,2])`和`foo(1,2)`是一样的，这样可以避免不必要的this绑定
#### 更安全的this
- 一种“更安全”的做法是传入一个特殊的对象，把this绑定到这个对象不会对你的程序产生任何副作用。就像网络（以及军队）一样，我们可以创建一个“DMZ”（demilitarized zone, 非军事区）对象——它就是一个空的非委托的对象
- 如果我们在忽略this绑定时总是传入一个DMZ对象，那就不用担心this的安全问题了，因为任何对于this的使用都会被限制在这个空对象中，不会对全局对象产生任何影响。
- 在javascript中创建一个空对象最简单的方法是`Object.create(null)`。`Object.create(null)`和`{}`很像，但是并不会创建`Object.prototype`这个委托，所以它比`{}`“更空”。
### 间接引用
- 间接引用最容易在赋值时发生

### 软绑定
- 硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改`this`
- 如果可以给默认绑定指定一个全局对象和`undefined`以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改`this`的能力


## 手写bind
- `bind`有如下特性
  - 指定`this`
  - 传入参数
  - 返回一个函数
  - 柯里化（函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式）

