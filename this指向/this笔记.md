# 第一章 关于this
## 💥调试
用 `debugger`
## 为什么要用`this`
- `this`提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用
- 随着使用的模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用`this`则不会这样
## `this`在任何情况下都不指向函数的词法作用域？为啥？

## `this`到底是什么？
- ❓❓❓❓`this`是在运行时进行绑定的，并不是在编写时绑定（两者有啥区别吗？？？？？？？
- `this`的上下文取决于函数调用时的各种条件
- `this`的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式
- 当一个函数被调用时，会创建一个执行上下文（execution context），这个execution context会包含函数在哪里被调用（调用栈 call stack）、函数的调用方式、传入的参数等信息。`this`就是这个execution context的一个属性，会在函数执行的过程中用到

## 小结
- `this`既不指向函数自身也不指向函数的词法作用域
- `this`实际上是在函数被**调用**时发生的绑定，它指向什么完全取决于函数在哪里被**调用**

# 第二章 this全面解析
## 调用位置
- 调用位置就是函数在代码中被调用的位置（而不是声明的位置）
- 我们要找的调用位置就在当前执行的函数的前一个调用中

## 1. 默认绑定
- 立即执行函数中调用函数，this指向问题？

## 2. 隐式绑定
- 调用位置是否有上下文对象，或者说是否被某个对象拥有或包含
- 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象
- ⭐对象属性引用链中只有上一层或者说最后一层在调用位置起作用（就近原则？）
- 在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上
## 隐式丢失
- 一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。
- 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值
- 调用回调函数的函数可能会修改this

## 3. 显式绑定
- 显式绑定：使用call或者apply方法，在调用函数时将其绑定到this，它们第一个参数可以指定this绑定的对象
- 从this绑定的角度来说，call()和apply()是一样的，它们的区别体现在其他的参数上
- ❓传入原始值作为this绑定对象？？？“装箱”？

## 硬绑定（显示绑定的变种

## API调用的“上下文”
- 第三方库的许多函数，以及javascript语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和bind()一样，确保你的回调函数使用指定的this
- 例如forEach(),这些函数实际上就是通过call()或者apply()实现了显式绑定
## 4. new绑定
- 在javascript中，构造函数只是一些使用new操作符时被调用的函数
- 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
  - 创建（或者说构造）一个全新的对象
  - 这个新对象会被执行`[[Prototype]]`连接
  - 这个新对象会绑定到函数调用的this
  - 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象

## 优先级
- 默认绑定优先级最低
- 显式绑定优先级 > 隐式绑定优先级

